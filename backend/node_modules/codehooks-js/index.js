let cronjob = null;
let coderun = null;


/**
* getMany options for query filtering, indexes and projections 
* @typedef {Object} getManyOptions
* @property {Object} filter - MongoDB query filter. (Read query language docs)
* @property {string} useIndex - indexed field name. 
- Indexes are created with CLI, e.g. coho createindex -c sales -i Region
* @property {string} startIndex - jump into the index
* @property {string} endIndex - where to end in the index
* @property {number} limit - how many items to return
* @property {Object} hints - include or omit fields. 
- Include fields example: {$fields: {name: 1, address: 1}. 
- Omit fields example: {$fields: {name: 0, _id_: 0}}
* @property {number} offset - how many items to skip before returning any
* @property {boolean} reverse - reverese scan of index, i.e. descending sort
*/

/**
* updateMany options
* @typedef {Object} updateOptions
* @property {Object} filter - MongoDB query filter. (Read query language docs)
* @property {string} useIndex - indexed field name. Indexes are created with CLI, 
- e.g. coho createindex -c sales -i Region
* @property {string} startIndex - jump into the index
* @property {string} endIndex - where to end in the index
*/

/**
* keyvalOptions
* @typedef {Object} keyvalOptions
* @property {number} ttl - Time to live in milliseconds
* @property {string} keyspace - Name of isolated keyspace
*/

/**
 * NoSQL API
 * @typedef {Object} NoSQLAPI
 * @property {function(objectID.<string|Array.<string>):Promise.<Object>} getOne - Get object by ID, returns a Promise with the object
 * @property {function(getManyOptions):DataStream} getMany - Get stream of objects by query
 * @property {function(getManyOptions):DataStream} find - Get stream of objects by query, alias for getMany
 * @property {function(json.<object>):Promise.<Object>} insertOne - Insert a new data object into a collection in the current Datastore
 * @property {function(objectID.<string>, document.<Object>):Promise.<Object>} updateOne - Update one data object by ID in a datastore collection. 
 * - Input document is patched with the matched database object
 * @property {function(document.<Object>, updateOptions):Promise.<Object>} updateMany - Update multiple data objects in a datastore collection. 
 * - Input document is patched with the matched database objects
 * @property {function(objectID.<string>, document.<Object>):Promise.<Object>} replaceOne - Replace one data object by ID in a datastore collection. 
 * - Input document overwrites the matched database object, the _id value is not overwritten. 
 * @property {function(document.<Object>, updateOptions):Promise.<Object>} replaceMany - Replace multiple data objects in a datastore collection. 
 * - Input document overwrites the matched database objects. The _id value is not overwritten
 * @property {function(objectID.<string>):Promise.<Object>} removeOne - Remove one data object by ID in a collection in the current Datastore
 * @property {function(updateOptions):Promise.<Object>} removeMany - Remove multiple data objects in a collection in the current Datastore
 */

/**
 * Database API
 * @typedef {Object} DatastoreAPI
 * @property {function(collection.<string>):NoSQLAPI} collection - Get database collection by string name, returns an NoSQL API object
 * @property {function(collection.<string>, objectID.<string|Array.<string>):Promise.<Object>} getOne - Get object by ID, returns a Promise with the object
 * @property {function(collection, getManyOptions):DataStream} getMany - Get stream of objects by query
 * @property {function(collection.<string>, json.<object>):Promise.<Object>} insertOne - Insert a new data object into a collection in the current Datastore
 * @property {function(collection.<string>, objectID.<string>, document.<Object>):Promise.<Object>} updateOne - Update one data object by ID in a datastore collection. 
 * - Input document is patched with the matched database object
 * @property {function(collection.<string>, document.<Object>, updateOptions):Promise.<Object>} updateMany - Update multiple data objects in a datastore collection. 
 * - Input document is patched with the matched database objects
 * @property {function(collection.<string>, objectID.<string>, document.<Object>):Promise.<Object>} replaceOne - Replace one data object by ID in a datastore collection. 
 * - Input document overwrites the matched database object, the _id value is not overwritten. 
 * @property {function(collection.<string>, document.<Object>, updateOptions):Promise.<Object>} replaceMany - Replace multiple data objects in a datastore collection. 
 * - Input document overwrites the matched database objects. The _id value is not overwritten
 * @property {function(collection.<string>, objectID.<string>):Promise.<Object>} removeOne - Remove one data object by ID in a collection in the current Datastore
 * @property {function(collection.<string>, updateOptions):Promise.<Object>} removeMany - Remove multiple data objects in a collection in the current Datastore
 * @property {function(key.<string>, value<string>, keyvalOptions):Promise.<Object>} set - Set a key-value pair in the current Datastore
 * @property {function(key.<string>, keyvalOptions):Promise.<Object>} get - Get a key-value pair in the current Datastore
 * @property {function(keypattern.<string>, keyvalOptions):DataStream} getAll - Get all key-value pair that matches keypattern in the current Datastore
 * @property {function(key.<string>, number, keyvalOptions):Promise.<Object>} incr - Increment a key-value pair in the current Datastore
 * @property {function(key.<string>, number, keyvalOptions):Promise.<Object>} decr - Decrement a key-value pair in the current Datastore
 * @property {function(key.<string>, keyvalOptions):Promise.<Object>} del - Delete a key-value pair in the current Datastore
 * @property {function(keypattern.<string>, keyvalOptions):Promise.<Object>} delAll - Delete a range of key-value pairs in the current Datastore
 * @property {function(topic.<string>, payload.<Object>, options.<Object>):Promise.<Object>} enqueue - Add a queued job in a datastore. 
 * - Jobs in the queue are processed by your worker function.
 * @property {function(collection.<string>, query.<Object>, topic.<string>, payload.<Object>, options.<Object>):Promise.<Object>} enqueueFromQuery - Add multiple queued jobs from the result of a database query in a datastore. 
 * - Each object from the collection in the query result will be processed by your worker function. 
 * - If your collection has 1000 items, a match all query ({}) will add 1000 items to the queue and call your worker function 1000 times.
*/

/**
* Persistent NoSql and Kev-Value datastore
* @typedef {Object} DataStream
* @property {function("data"|"end"|"error", callback.<Function>):DataStream} on - Emits data, stream.on('data', (data) => //console.debug(data))
* @property {function(httpResponse)} json - Pipe datastream to JSON output
*/

/**
 * Built-in persistent datastore.
 * - Datastore is capable of serving NoSQL object data and Key-Value data.
 * @typedef {Object} Datastore
 * @property {function():Promise.<DatastoreAPI>} open - Connect to Datastore
 */

/**
 * @typedef {Object} httpRequest
 * @property {object} headers - HTTP header key value pairs, e.g. req.headers['content-type']
 * @property {object} query - Get the URL query parameters as key-value pairs
 * @property {object} params - Get the URL route variables as key-value pairs
 * @property {object} body - Get the request body
 * @property {object} path - Get the URL full path
 * @property {object} apipath - Get the URL api path
 * @property {object} originalUrl - Get the URL full path and query parameter string
 * @property {object} method - Get the HTTP request verb
 * @property {object} hostname - Get the project URL domain name
 */

/**
 * @typedef {Object} httpResponse
 * @property {function(data.<string>)} end - End request (optional: send text data to client)
 * * @property {function(data.<string>)} send - Send text data to client and end request
 * @property {function(data.<json>)} json - End request and send JSON data to client
 * @property {function(data.<string>)} write - Write stream data to the client response. 
 * - Content-type must be set before any write operations
 * @property {function(header.<string>, value.<string>)} set - Set a response header value, 
 * - e.g. res.set('Content-Type', 'text/html; charset=UTF-8');
 * @property {function(headers.<json>)} headers - Set multiple response header values, 
 * - e.g. res.headers({'Content-Type': 'text/html; charset=UTF-8','X-myheader': '123456890'});
 * @property {function(HttpStatusCode.<number>)} status - Return a HTTP response status code for a client request, 
 * - e.g. res.status(401);
 */


class Codehooks {
  /**
   * Express style api
   */
  routes = {};
  queues = {};
  jobs = {};
  auths = {};
  appmiddleware = [];
  datastore = null;
  listeners = [];
  workers = {};

  /**
   * POST requests - e.g. app.post('/foo', callbackFunction)
   * @example
   * app.post('/myroute', (req, res) => {
   *  //console.debug('Body', req.body)
   *  res.json({"message": "thanks!"})
   * })
   * @param {string} path - API route, e.g. '/foo'
   * @param  {...function(httpRequest, httpResponse)} hook - callback function(s) with parameters (req, res, [next])
   */
  post = (path, ...hook) => {
    this.routes[`POST ${path}`] = hook;
  };

  /**
   * GET requests - e.g. app.get('/foo/:ID', callbackFunction)
   * @example
   * app.get('/myroute', (req, res) => {
   *  //console.debug('Params', req.params)
   *  res.json({"message": "thanks!"})
   * })
   * @param {string} path - API route, e.g. '/foo/:ID'
   * @param  {...function(httpRequest, httpResponse)} hook - callback function(s) with parameters (req, res, [next])
   */
  get = (path, ...hook) => {
    this.routes[`GET ${path}`] = hook;
  };

  /**
   * PUT requests
   * @example
   * app.put('/myroute', (req, res) => {
   *  //console.debug('Body', req.body)
   *  res.json({"message": "thanks!"})
   * })
   * @param {string} path - API route, e.g. '/foo/:ID'
   * @param  {...function(httpRequest, httpResponse)} hook - callback function(s) with parameters (req, res, [next])
   */
  put = (path, ...hook) => {
    this.routes[`PUT ${path}`] = hook;
  };

  /**
   * PATCH requests
   * @example
   * app.patch('/myroute', (req, res) => {
   *  //console.debug('Body', req.body)
   *  res.json({"message": "thanks!"})
   * })
   * @param {string} path - API route, e.g. '/foo/:ID'
   * @param  {...function(httpRequest, httpResponse)} hook - callback function(s) with parameters (req, res, [next])
   */
  patch = (path, ...hook) => {
    this.routes[`PATCH ${path}`] = hook;
  };

  /**
   * DELETE requests - app.delete('/foo', callbackFunction)
   * @example
   * app.delete('/myroute', (req, res) => {
   *  res.json({"message": "thanks!"})
   * })
   * @param {string} path - API route, e.g. '/foo/:ID'
   * @param  {...function(httpRequest, httpResponse)} hook - callback function(s) with parameters (req, res, [next])
   */
  delete = (path, ...hook) => {
    this.routes[`DELETE ${path}`] = hook;
  };

  /**
   * All HTTP methods - app.all('/pets/cat', (req, res) => res.end('Mjau'))
   * @example
   * app.all('/myroute', (req, res) => {
   *  //console.debug('Body', req.body || 'no body')
   *  res.json({"message": "thanks!"})
   * })
   * @param {string} path - API route, e.g. '- API endpoint route, e.g. '/pets' 
   * @param  {...function(httpRequest, httpResponse)} hook - callback function(s) with parameters (req, res, [next])
   */
  all = (path, ...hook) => {
    this.routes[`* ${path}`] = hook;
  };

  /**
   * Allow custom authentication
   * @example
   * app.auth('/*', (req, res, next) => {
   *  if (1 === 1) {
   *    next()
   *  } else {
   *    res.status(403).end('No soup!')
   *  }
   * })
   * @param {string} path - API route, e.g. '/foo/*'
   * @param  {...function(httpRequest, httpResponse)} hook - callback function(s) with parameters (req, res, [next])
   */
  auth = (path, ...hook) => {
    this.auths[path] = hook;
  };

  /**
   * Global middleware
   * @example
   * // global middleware
   * app.use((req, res, next) => {
   *  //console.debug("Global middleware was here!");
   *  next(); // proceed
   * })
   * // middleware on a specific route
   * app.use('/myroute', (req, res, next) => {
   *  //console.debug("Route middleware was here!");
   *  next(); // proceed
   * })
   * @param {string} path - Optional API route, e.g. '/myroute/*'
   * @param  {...function(httpRequest, httpResponse, next.<function>)} hook - callback function(s) with parameters (req, res, next)
   */
  use = (...hook) => {
    if (typeof hook[0] === 'string') {
      this.appmiddleware.push({ path: hook[0], func: hook[1] });
    } else {
      this.appmiddleware.push(hook);
    }
    this.appmiddleware = this.appmiddleware.flat();
  };

  /**
   * Process queue job items for topic
   * @param {string} topic 
   * @param  {...function(httpRequest, httpResponse)} hook - callback function(s) with parameters (req, res, [next])
   */
  queue = (topic, ...hook) => {
    this.queues[topic] = hook;
  };

  /**
   * Add application worker function
   * @param {string} name a unique worker name 
   * @param  {...function(httpRequest, httpResponse)} hook - callback function(s) with parameters (req, res, [next])
   * @example
   * app.worker('myworker', (data, job) => {
   *  const {body:{payload}} = data
   *  //console.debug('worker payload data', payload) 
   *  // do stuff with payload data
   *  job.end()
   *})
   */
  worker = (name, ...hook) => {
    this.workers[name] = hook;
    this.queues[name] = hook; // legacy support
  };

  /**
   * Create cron background jobs
   * @example 
   * // call function each minute
   * app.job('* * * * *', (req, res) => {
   *  //console.debug('tick each minute')
   *  res.end()
   * })
   * @param {string} cronExpression - cron expression
   * @param  {...function(httpRequest, httpResponse)} hook - callback function(s) with parameters (req, res, [next])
   */
  job = (cronExpression, ...hook) => {
    this.jobs[cronExpression] = hook;
  }

  /**
   * Returns the Codehooks serverless definitions used by a serverless runtime engine
   * @example
   * export default app.init();
   * @returns {Object} App instance manifest
   */
  init = () => {
    const manifest = {
      workerhooks: this.workers,
      routehooks: this.routes,
      queuehooks: this.queues,
      jobhooks: this.jobs,
      authhooks: this.auths,
      globalhooks: this.appmiddleware,
      useExpress: this.useExpress,
      app: this
    };
    return manifest;
  };


  /**
   * Use Node Express app to run standalone
   * All Codehooks routes will be applied as Express Routes 
   * @param {Object} express app instance
   * @param {Object} options for Datastore and routing space 
   */
  useExpress = async (express, options) => {
    cronjob = import("./cronjob.mjs")
    coderun = import('./coderunner.mjs')
    const { datastore, space = '/dev' } = options;
    await datastore.connect();
    this.setDatastore(datastore);

    //console.debug('auth', this.auths)
    for (let key in this.auths) {
      const func = this.auth[key];
      console.error('Auth middleware not implemented:', key)
    }

    // apply middleware
    //console.debug('middleware', this.appmiddleware)
    for (let key in this.appmiddleware) {
      const func = this.appmiddleware[key];
      //console.debug('Apply express middleware', func);
      if (func.path) {
        express.use(`${space}${func.path}`, func.func);
      } else {
        express.use(func);
      }
    }

    // apply routes
    //console.debug('routes', this.routes)
    for (let key in this.routes) {
      const func = this.routes[key];
      const [method, route] = key.split(' ');
      //console.debug('Apply express routes', method, route, ...func);
      switch (method) {
        case 'GET': express.get(`${space}${route}`, ...func); break;
        case 'PUT': express.put(`${space}${route}`, ...func); break;
        case 'POST': express.post(`${space}${route}`, ...func); break;
        case 'PATCH': express.patch(`${space}${route}`, ...func); break;
        case 'DELETE': express.delete(`${space}${route}`, ...func); break;
        case '*': express.all(`${space}${route}`, ...func); break;
      }
    }

    // apply jobs
    //console.debug('jobs', this.jobs)
    for (let key in this.jobs) {
      const func = this.jobs[key];
      const cron = key;
      //console.debug('Apply job', cron, func);
      cronjob(cron, func);
    }

    // apply queue workers
    //console.debug('queues', this.queues)
    for (let key in this.queues) {
      const func = this.queues[key];
      const topic = key;
      //console.debug('Apply queue', topic, func);
      this.datastore.setQueue(topic, func);
    }
  }
  /**
   * Set Datastore interface
   * @param {*} ds 
   */
  setDatastore = (ds) => {
    this.datastore = ds;
    this.listeners.forEach(observer => observer(this))
  }

  getDatastore = () => {
    return {
      open: () => {
        //console.debug("Open datastore");
        return new Promise((resolve) => {
          resolve(this.datastore)
        })
      }
    }
  }
  addListener = (observer) => {
    this.listeners.push(observer);
  }
  static getInstance() {
    if (!this.instance) {
      this.instance = new Codehooks();
    }
    return this.instance;
  }
  
}


const _coho = Codehooks.getInstance();

let _ds = null;


try {
  DB;
  _ds = DB;
} catch (e) {
  if (e instanceof ReferenceError) {
    // Running standalone
    //console.debug("Standalone mode")
    _ds = _coho.getDatastore();
  }
}

/**
 * @type {Datastore}
 */
export const Datastore = _ds;
/**
 * @type {Datastore}
 */
export const datastore = _ds;

/**
 * Express style API
 * @type {Codehooks}
 */
export const coho = _coho;
export const app = _coho;
export const coderunner = coderun;
/**
 * @description Delayed invocation of a worker function
 */
export const schedule = {
  /**
   * Call worker function later
   * @param {Date} datetime to execute
   * @param {Object} payload data
   * @param {string} worker name
   * @example
   * var date = new Date();
   * // add a day
   * date.setDate(date.getDate() + 1);
   * await schedule.runAt(date, {"some": "json data"}, 'myworker')
   * @returns {Promise} Ticket object
   */
  "runAt": async (date, payload, worker) => {
    const conn = await datastore.open()
    return await conn.runAt(date, payload, worker)
  },
  /**
   * Call worker function immediate
   * @param {Object} payload to worker function
   * @param {string} worker name 
   * @example
   * await schedule.run({"some": "data"}, 'myworker')
   * @returns {Promise} Ticket object
   */
  "run": async (payload, worker) => {
    const conn = await datastore.open()
    return await conn.runAt(new Date(), payload, worker)
  }
}
/**
* @description The default app object
* @type {Codehooks}
*/
export default _coho;